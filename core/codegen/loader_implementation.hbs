
using namespace {{dtoNamespace}};

{{#each endpoints as |e|}}
{{#if e.endpoint.hasSuccessResponse}}

{{e.className}}Loader::{{e.className}}Loader(ApiClient *apiClient)
	: {{supportNamespace}}::HttpLoader<{{e.endpoint.resultType}}, {{e.endpoint.parameterType}}>(apiClient) {}

QString {{e.className}}Loader::path(const {{e.endpoint.parameterType}} &params) const {
	Q_UNUSED(params) // Might be overzealous, but I don't like theses kind of warnings
	
	return {{e.pathStringInterpolation "params"}};
}

QUrlQuery {{e.className}}Loader::query(const {{e.endpoint.parameterType}} &params) const {
	Q_UNUSED(params) // Might be overzealous, but I don't like theses kind of warnings

	QUrlQuery result;

	{{#each e.endpoint.requiredQueryParameters as |p|}}
	result.addQueryItem("{{p.name}}", Support::toString<{{p.type.typeNameWithQualifiers}}>(params.{{p.type.name}}()));

	{{/each}}

	// Optional parameters

	{{#each e.endpoint.optionalQueryParameters as |p|}}
	if (!params.{{p.type.name}}Null()) {
		result.addQueryItem("{{p.name}}", Support::toString<{{p.type.typeNameWithQualifiers}}>(params.{{p.type.name}}()));
	}

	{{/each}}
	
	return result;
}

{{/if}}
{{/each}}
